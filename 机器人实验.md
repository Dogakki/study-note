

## 实现目标：

​		使用相机拍摄白纸上写的汉字，编写机器视觉程序提取汉字轮廓，编写机器人程序控制机器人沿着汉字轮廓描边书写空心汉字。

①坐标系的转化

②轮廓坐标的提取

## 一、相机标定

采用张正友标定法

#### 内参标定

下图为内参矩阵

![img](https://img-blog.csdnimg.cn/b72479ba02e143728018cba32ebb9a5a.png)

**内参有4个内参数（fx,fy,cx,cy）和 5个畸变参数——3个径向（k1,k2,k3)和俩个切向（p1，p2）；
内参数直接与棋盘所在空间的3D几何相关（即外参数），而畸变参数则与点集如何畸变的2D集合相关。**

1.使用opencv进行标定

```c
#include <iostream>
#include <fstream>
#include <string>
#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc.hpp>

using namespace std;
using namespace cv;

int main()
{
	string dir = "C:\\Users\\User\\Desktop\\calibdata\\"; // 存储标定图片路径的txt文件所在路径
	ifstream fin(dir + "calivdata.txt");                                  // 读取标定图片的路径，以输入方式打开文件
	if (!fin)
	{
		cerr << "没有找到文件" << endl;
		return -1;
	}
	ofstream fout(dir + "calibration_result.txt");     // 输出结果保存在此文本文件下，以输出方式打开文件

cout << "1、开始提取角点……" << endl;             // points_all_images
int image_nums = 0;                                // 有效图片数量统计
int points_per_row = 7;                            // 标定版每行的内点数
int points_per_col = 7;                            // 标定版每列的内点数
Size image_size;                                   // 图片尺寸
Size corner_size(points_per_row, points_per_col);  // 标定板每行每列角点个数，共7*7个角点
vector<Point2f> points_per_image;                  // 缓存每幅图检测到的角点
vector<vector<Point2f>> points_all_images;         // 保存检测到的所有角点
string image_file_name;			                   // 声明一个文件名的字符串
Mat image_raw, image_gray;                         // 彩色图，灰度图
//while (fin.get(image_file_name, 35))
while (getline(fin, image_file_name, '\n'))
{
	image_raw = imread(image_file_name);                                             // 按照RGB图像读取数据
	cvtColor(image_raw, image_gray, COLOR_BGR2GRAY);                                 // 将BGR图转化为灰度图
	bool success = findChessboardCorners(image_gray, corner_size, points_per_image); // 角点检测
	if (!success)
	{
		cout << "角点提取失败" << endl;
		exit(1);  // 非正常执行导致退出程序
	}
	else
	{
		cornerSubPix(image_gray, points_per_image, Size(5, 5), Size(-1, -1), TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, 0.1)); // 亚像素角点，也可使用cornerSubPix()
		points_all_images.push_back(points_per_image);                   // 保存亚像素角点
	}
	if (image_nums == 0)
	{
		cout << "channels = " << image_raw.channels() << endl;  // 图像的通道数
		cout << "image type = " << image_raw.type() << endl;    // 数据类型，CV_8UC3
		image_size.width = image_raw.cols;                      // 图像的宽,对应着列数(x)
		image_size.height = image_raw.rows;                     // 图像的高,对应着行数(y)
		cout << "image width = " << image_size.width << endl;   // 打印图像宽
		cout << "image height = " << image_size.height << endl; // 打印图像高
	}
	image_nums++;
}
cout << "image_nums = " << image_nums << endl;     // 输出图像数目

cout << "2、开始计算角点3D坐标……" << endl;     // points3D_all_images
Size block_size(10, 10);                         // 每个小方格实际大小10mm,(w,h)
vector<Point3f> points3D_per_image;              // 初始化角点三维坐标,从左到右,从上到下
Point3f point3D;                                 // 3D点(x,y,z)
for (int i = 0; i < corner_size.height; i++)     // 第i行---y
{
	for (int j = 0; j < corner_size.width; j++)  // 第j列---x
	{
		point3D = Point3f(block_size.width * j, block_size.height * i, 0);
		points3D_per_image.push_back(point3D);
	}
}
vector<vector<Point3f>> points3D_all_images(image_nums, points3D_per_image); // 保存所有图像角点的三维坐标
int point_counts = corner_size.area();                                       // 每张图片上角点个数

cout << "3、开始标定相机……" << endl;           // calibrateCamera
Mat cameraMat(3, 3, CV_32FC1, Scalar::all(0));   // 内参矩阵3*3
Mat distCoeffs(1, 5, CV_32FC1, Scalar::all(0));  // 畸变矩阵1*5，既考虑径向畸变，又考虑切向
vector<Mat> rotationMat;                         // 旋转矩阵
vector<Mat> translationMat;                      // 平移矩阵
calibrateCamera(points3D_all_images, points_all_images, image_size, cameraMat, distCoeffs, rotationMat, translationMat, 0); // 标定

cout << "4、开始对标定结果进行评价……" << endl; // projectPoints
double total_err = 0.0;                          // 所有图像平均误差总和
double err = 0.0;                                // 每幅图像的平均误差
vector<Point2f> points_reproject;                // 重投影点
fout << "计算每幅图像的标定误差：" << endl;
for (int i = 0; i < image_nums; i++)
{
	points_per_image = points_all_images[i];         // 第i张图像提取角点
	points3D_per_image = points3D_all_images[i];     // 第i张图像中角点的3D坐标
	projectPoints(points3D_per_image, rotationMat[i], translationMat[i], cameraMat, distCoeffs, points_reproject); // 重投影
	Mat detect_points_Mat(1, points_per_image.size(), CV_32FC2);  // 变为1*S的矩阵,2通道保存提取角点的像素坐标
	Mat points_reproj_Mat(1, points_reproject.size(), CV_32FC2);  // 变为1*S的矩阵,2通道保存投影角点的像素坐标
	for (int j = 0; j < points_per_image.size(); j++)
	{
		detect_points_Mat.at<Vec2f>(0, j) = Vec2f(points_per_image[j].x, points_per_image[j].y);
		points_reproj_Mat.at<Vec2f>(0, j) = Vec2f(points_reproject[j].x, points_reproject[j].y);
	}
	err = norm(points_reproj_Mat, detect_points_Mat, NormTypes::NORM_L2);  // 计算两者之间的误差
	total_err += err /= point_counts;
	fout << "第" << i + 1 << "幅图像的平均误差为： " << err << "像素" << endl;
}
fout << "总体平均误差为： " << total_err / image_nums << "像素" << endl << endl;

cout << "5、将标定结果写入文件……" << endl;
fout << "相机内参数矩阵:" << endl << cameraMat << endl << endl;
fout << "相机的畸变系数:" << endl << distCoeffs << endl << endl;
Mat rotate_Mat = Mat(3, 3, CV_32FC1, Scalar::all(0)); // 保存旋转矩阵
for (int i = 0; i < image_nums; i++)
{
	Rodrigues(rotationMat[i], rotate_Mat);  // 将旋转向量通过罗德里格斯公式转换为旋转矩阵
	fout << "第" << i + 1 << "幅图像的旋转矩阵为：" << endl << rotate_Mat << endl << endl;
	fout << "第" << i + 1 << "幅图像的平移向量为：" << endl << translationMat[i] << endl << endl;
}
fout << endl;
fout.close();

return 0;

}
```

2.使用Matlab进行标定

使用MatLab->APP->CameraCalibrator进行标定

![image-20231209105135345](E:\typora\Project\机器人实验.assets\image-20231209105135345.png)

再点击Calibrate进行校准![image-20231209105255256](E:\typora\Project\机器人实验.assets\image-20231209105255256.png)

右上角的为平均重投影误差，最好不要超过0.5，可将误差大的部分去掉，然后重新校验。

再点击Export Camera Parameters 可将参数输出到工作区

![image-20231209105902198](E:\typora\Project\机器人实验.assets\image-20231209105902198.png)

其中IntrinsicMatrix为内参矩阵，表示的

RadioDistortion 为径向畸变

TangentiaDistortion 为切向畸变





#### 外参标定

​		外参实际上是一个齐次变换矩阵，实现的是从相机坐标系到世界坐标系的转换，该其次变换矩阵由一个旋转矩阵和一个平移矢量组成。

![img](https://img-blog.csdnimg.cn/6c40cc74f54342459e0fafd3f6d78d78.png)

1.使用Opencv进行标定

```c++
#include <opencv2/opencv.hpp>
#include<opencv2/calib3d/calib3d.hpp>
#include <vector>
#include<iostream>
#include<Windows.h>

int main() {
    // 定义相机内参矩阵和畸变系数
    cv::Mat cameraMatrix = (cv::Mat_<double>(3, 3) << 15785.9164239007, 0, 1460.317236460725, 0, 15603.36620467085, 567.1768255696585, 0, 0, 1);
    cv::Mat distCoeffs = (cv::Mat_<double>(1, 5) << -1.096890265412666, 63.94728716044833, 0.02564332649241499, 0.003252879097841658, 3845.7168102075);

// 定义棋盘格大小
int chessboardWidth = 7;
int chessboardHeight = 7;

// 准备棋盘格角点的容器
std::vector<std::vector<cv::Point3f>> objectPoints;
std::vector<std::vector<cv::Point2f>> imagePoints;

// 生成棋盘格上的三维点
std::vector<cv::Point3f> obj;
for (int i = 0; i < chessboardHeight; ++i) {
    for (int j = 0; j < chessboardWidth; ++j) {
        obj.push_back(cv::Point3f(j, i, 0));
    }
}

// 每一幅图像的旋转矩阵和平移向量
std::vector<cv::Mat> rotationMatrices;
std::vector<cv::Mat> translationVectors;

// 添加每一幅图像的旋转矩阵和平移向量
// 请确保数据结构和变量名与实际情况一致
rotationMatrices.push_back((cv::Mat_<double>(3, 3) << 0.9825361097917864, -0.002771289593838277, -0.1860513716939752, 0.009498016361687388, 0.9993325572067214, 0.03527361325223054, 0.1858294396494155, -0.03642471771561036, 0.9819066449000752));
translationVectors.push_back((cv::Mat_<double>(3, 1) << -46.51606971766573, -3.968750916976453, 1648.272082308243));



// 读取图像并查找棋盘格角点
cv::Mat img = cv::imread("C:\\Users\\User\\Desktop\\calibdata\\image\\hui.bmp");
cv::Mat gray;
cv::cvtColor(img, gray, cv::COLOR_BGR2GRAY);

std::vector<cv::Point2f> corners;
bool patternFound = cv::findChessboardCorners(gray, cv::Size(chessboardWidth, chessboardHeight), corners);

if (patternFound) {
    cv::cornerSubPix(gray, corners, cv::Size(11, 11), cv::Size(-1, -1), cv::TermCriteria(cv::TermCriteria::EPS + cv::TermCriteria::COUNT, 30, 0.1));
    imagePoints.push_back(corners);
    objectPoints.push_back(obj);
}

// 相机位姿估计
cv::Mat rvec, tvec;
cv::solvePnP(objectPoints[0], imagePoints[0], cameraMatrix, distCoeffs, rvec, tvec);

// 将旋转向量转换为旋转矩阵
cv::Mat rotationMatrix;
cv::Rodrigues(rvec, rotationMatrix);

// 打印结果
std::cout << "Rotation Matrix:\n" << rotationMatrix << "\n\n";
std::cout << "Translation Vector:\n" << tvec << "\n";
Sleep(10 * 1000);
return 0;

}
```

2.使用Matlab进行标定

![image-20231209105902198](E:\typora\Project\机器人实验.assets\image-20231209105902198.png)

其中RotationMatrices为旋转矩阵，TranslationVectors为平移向量。

在求出内外参矩阵后，将两矩阵相乘，可以得到相机坐标系到世界坐标系的转换。

![image-20231209114048073](E:\typora\Project\机器人实验.assets\image-20231209114048073.png)



## 二、世界坐标系与机械臂坐标系的转变

​		在工件坐标系上取三个点，分别为工件坐标系原点、x轴上的一点、y轴上的一点，记录这三个点在机器人坐标系中的坐标，并计算出工件坐标系到机器人坐标系的变换矩阵（可以不考虑z轴，仅考虑x、y轴）

![img](https://picx.zhimg.com/v2-52b964c6bb15062cd24b32fc301b03be_r.jpg?source=1def8aca)

通过已知的机械臂自身的坐标系和工件坐标系，可以算出坐标系之间的齐次变换。由于绘图面是一个平面，所以无须考虑z轴的转变，只用计算xyz轴的变化

```python
Q0=np.array([144.4916,9.4081])
Q1=np.array([258.2910,9.4083])
Q2=np.array([145.4906,-9.3005])
Vx=Q1-Q0
Vy=Q2-Q0
Vx=Vx/np.linalg.norm(Vx)
Vy=Vy/np.linalg.norm(Vy)
R=np.column_stack((Vx,Vy))
T=np.column_stack((R,Q0)).T
```



此时可以得到世界坐标系与机械臂坐标系之间的齐次转化矩阵，将上一步得到的矩阵与此矩阵点乘，可以得到相机坐标系与机械臂坐标系的转换。



## 三、轮廓提取

利用OpenCV对图像轮廓进行提取，将轮廓上的点以相机坐标系内坐标的形式输出。

```c++
#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc.hpp>
#include <iostream>
#include <fstream>
#include <vector>

using namespace cv;
using namespace std;

int main() {
    Mat image1;
    // 读取图像
    Mat image = imread("C:\\Users\\User\\Desktop\\calibdata\\image\\lunkuo1.bmp", 0);
    if (image.empty()) {
        cerr << "Failed to read image." << endl;
        return -1;
    }
    // 二值化处理
    Mat binary;
    threshold(image, binary, 70, 255, THRESH_BINARY_INV);
    dilate(binary, image1, Mat(), Point(-1, -1), 3);
    erode(binary, image1, Mat(), Point(-1, -1), 11);
    imshow("2", binary);

// 轮廓检测
vector<vector<Point>> contours;
findContours(binary, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE, Point(0, 0));

// 绘制轮廓
Mat result;
cvtColor(binary, result, COLOR_GRAY2BGR);
drawContours(result, contours, -1, Scalar(0, 0, 255), 2);

// 存储轮廓点
vector<Point> contourPoints;
for (const auto& contour : contours) {
    for (const auto& point : contour) {
        contourPoints.push_back(point);
    }
}

// 打开文件
ofstream outputFile("contour_points.txt");
if (!outputFile.is_open()) {
    cerr << "Failed to open output file." << endl;
    return -1;
}

// 将轮廓点写入文件
for (const auto& point : contourPoints) {
    outputFile << point.x << " " << point.y << endl;
}

// 关闭文件
outputFile.close();

// 显示图像
imshow("Image", result);
waitKey(0);

return 0;

}

```

将相机系内坐标转为机械臂坐标后，让机械臂沿着路径运动即可以实现轮廓绘图